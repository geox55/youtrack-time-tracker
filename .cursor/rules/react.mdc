---
description: React rules
globs:
alwaysApply: true
---

# TypeScript & React правила

## Типизация компонентов

- Типизируй пропсы через интерфейсы с суффиксом Props.

✅ `interface ButtonProps { onClick: () => void }`  
❌ `type ButtonType = { onClick: Function }`

- Используй `React.FC` только когда нужны дополнительные свойства.

✅ `const Button = ({ onClick }: ButtonProps) => <button onClick={onClick} />`  
❌ `const Button: React.FC<ButtonProps> = ({ onClick }) => ...`

## Хуки

- Типизируй useState явно при сложных типах.

✅ `const [user, setUser] = useState<User | null>(null)`  
❌ `const [user, setUser] = useState(null)` без типа

- Создавай кастомные хуки с явными возвращаемыми типами.

✅ `function useUser(): { user: User | null, loading: boolean }`  
❌ `function useUser()` без типа возврата

## Обработчики событий

- Используй правильные типы для event handlers.

✅ `const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {}`  
❌ `const handleClick = (e: any) => {}`

- Типизируй формы через generic параметры.

✅ `const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {}`  
❌ `const handleSubmit = (e) => {}` без типа

## Рефы

- Типизируй useRef правильно для DOM элементов.

  ✅ `const inputRef = useRef<HTMLInputElement>(null)`  
  ❌ `const inputRef = useRef(null)` без типа

- Используй forwardRef с типами для переиспользуемых компонентов.

  ✅ `const Input = forwardRef<HTMLInputElement, InputProps>((props, ref) => ...)`  
  ❌ `const Input = forwardRef((props, ref) => ...)` без типов

## Контекст

- Типизируй контекст через интерфейсы.

  ✅ `interface UserContextType { user: User | null, login: (user: User) => void }`  
  ❌ `const UserContext = createContext({})` без типов

- Создавай кастомные хуки для контекста с проверками.

  ✅ `function useUserContext(): UserContextType { const context = useContext(UserContext); if (!context) throw new Error('useUserContext must be used within UserProvider'); return context; }`  
  ❌ Прямое использование `useContext` без проверок

## Дети компонентов

- Используй правильные типы для children.

  ✅ `interface Props { children: React.ReactNode }`  
  ❌ `interface Props { children: any }`

- Типизируй render props явно.

  ✅ `interface Props { render: (data: User) => React.ReactElement }`  
  ❌ `interface Props { render: Function }`

## Состояние

- Типизируй сложное состояние через интерфейсы.

  ✅ `interface FormState { name: string, email: string, errors: Record<string, string> }`  
  ❌ Использование `any` для состояния формы

- Используй дискриминированные unions для состояний загрузки.

  ✅ `type AsyncState<T> = {status: 'idle'} | {status: 'loading'} | {status: 'success', data: T} | {status: 'error', error: string}`  
  ❌ `interface State { loading: boolean, data?: T, error?: string }`

## Пропсы по умолчанию

- Используй деструктуризацию с значениями по умолчанию.

  ✅ `const Button = ({ variant = 'primary', ...props }: ButtonProps) => {}`  
  ❌ `Button.defaultProps = { variant: 'primary' }`

- Типизируй optional пропсы правильно.

  ✅ `interface Props { title?: string }`  
  ❌ `interface Props { title: string | undefined }`